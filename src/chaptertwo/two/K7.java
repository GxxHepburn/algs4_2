package chaptertwo.two;

/**
 * 前提:N+1的前N个元素相同。因为如果不相同，那么C(N)有可能是N/2lgN的，而C(N+1)是NlgN的
 * 证明:
 *      自顶向下
 *          一、N=1,N=2时成立
 *          二、假设C(N+1) > C(N)
 *              C(N) = C(l N/2) + C(r N/2) + m
 *              C(N+1) = C(l (N+1)/2) + C(r (N+1)/2) + m + 1?
 *              N = 2^n时
 *              C(N+1) = C(l N/2) + C(r (N+1)/2) + m + 1?
 *              可知C(r (N+1)/2) >= C(r N/2) 前者比后者多最后一个元素，除最后一个元素外，全部相同
 *              N = 2^n + 1时
 *              C(N+1) = C(l N/2+1) + C(r (N+1)/2) + m + 1?
 *              由假设可知C(l N/2+1) > C(l N/2)
 *
 *           三、零C(N+1)最后的常数=t
 *           C(N+2) = C(l (N+2)/2) + C(r + (N+2)/2) + t + 1?
 *           N = 2^n时
 *           C(N+2) = C(l N/2 + 1) + C(r (N+2)/2) + t + 1?
 *           C(r (N+2)/2) >= C(r (N+1)/2) 原式成立
 *           N = 2^n+1时
 *           C(N+2) = C(l N/2+1) + C(r (N+2)/2) + t + 1?
 *           C(r (N+2)/2) >= C(r (N+1)/2) 原式成立
 *           综上自顶向下归并排序时，比较次数是单调递增的
 *
 *     自底向下
 *          处理一个数组的遍数正好是lgN，比较次数是N/2~N
 *          很明显:C(N+1)每一遍比较次数都>=C(N)比较次数
 *          所以C(N+1) > C(N)
 * 实验: K6的结果表明归并排序的比较次数是单调递增的。
 */
public class K7 {
}
